%{        
int yydebug = 1;
%}

%define parse.trace

/* calculator with AST */
%language "c++"

/* write out a header file containing the token defines */
%defines

/* use newer C++ skeleton file */
%skeleton "lalr1.cc"
%define "parser_class_name" {Parser}
%parse-param { class Driver& driver }

%code requires{
#include "ast.hpp"
}


%code top {
        
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include "lexer.h"
#include "declarations.hpp"
#include "driver.h"
#undef yylex
#define yylex driver.lexer->lex

}


%start start
%error-verbose

%locations 
%initial-action
{
    @$.begin.filename = @$.end.filename = &driver.streamname;
};

%union {
        ASTNodeBase *a;
}
/* declare tokens */

%token END 0

%token <a> ID
%token <a> NUMBER
%token <a> STRING_LITERAL
%token <a> TRUE
%token <a> FALSE
%token <a> BOOLEAN
%token <a> INT

%left <a> PLUS
%left <a> MINUS
%left <a> MULTIPLY
%left <a> DIVIDE
%left <a> MODULO

%left <a> AND
%left <a> OR

%token <a> IF
%token <a> ELSE
%token <a> WHILE
%token <a> VOID
%token <a> RETURN
%token <a> BREAK

%right <a> ASSIGNMENT
%right <a> NOT
%token <a> LT
%token <a> GT
%token <a> GE
%token <a> LE
%token <a> EQ
%token <a> NE

%expect 1

%token <a> PARENTHESIS_OPEN
%token <a> PARENTHESIS_CLOSE
%token <a> BRACE_OPEN
%token <a> BRACE_CLOSE
%token <a> SEMICOLON
%token <a> COMMA

%type <a> globaldeclarations
%type <a> globaldeclaration
%type <a> variabledeclaration
%type <a> identifier
%type <a> functiondeclaration
%type <a> functionheader
%type <a> functiondeclarator
%type <a> formalparameterlist
%type <a> formalparameter
%type <a> mainfunctiondeclaration
%type <a> mainfunctiondeclarator
%type <a> block
%type <a> blockstatements
%type <a> blockstatement
%type <a> statement
%type <a> statementexpression
%type <a> primary
%type <a> argumentlist
%type <a> functioninvocation
%type <a> postfixexpression
%type <a> unaryexpression
%type <a> multiplicativeexpression
%type <a> additiveexpression
%type <a> relationalexpression
%type <a> equalityexpression
%type <a> conditionalandexpression
%type <a> conditionalorexpression
%type <a> assignmentexpression
%type <a> assignment
%type <a> expression
%type <a> literal
%type <a> type
%type <a> start

%%

start   : /* nothing */ { $$ = new ASTNode("code"); }
        | globaldeclarations { $$ = new ASTNode("code", {$1}); 
                               std::cout << *$$; } // print out AST
        ;

literal : NUMBER
        | STRING_LITERAL
        | TRUE
        | FALSE

type    : BOOLEAN
        | INT
        ;

globaldeclarations      : globaldeclaration { $$ = new ASTNode("global declarations", {$1}); }
                        | globaldeclarations globaldeclaration { $$->add($2); }
                        ;

globaldeclaration       : variabledeclaration 
                        | functiondeclaration 
                        | mainfunctiondeclaration
                        
                        ;

variabledeclaration     : type identifier SEMICOLON { $$ = new ASTNode("variable declaration", {$1, $2}); }
                        ;

identifier              : ID 
                        ;

functiondeclaration     : functionheader block 
                        { $$ = new ASTNode("function declaration", {$1, $2}); }
                        ;

functionheader          : type functiondeclarator { $$ = new ASTNode("function header", {$1, $2}); }

                        | VOID functiondeclarator { $$ = new ASTNode("function header", {$1, $2}); }
                        ;

functiondeclarator      : identifier PARENTHESIS_OPEN formalparameterlist PARENTHESIS_CLOSE { $$ = new ASTNode("function declarator", {$1, $3}); }
                        | identifier PARENTHESIS_OPEN PARENTHESIS_CLOSE { $$ = new ASTNode("function declarator", {$1}); }
                        ;

formalparameterlist     : formalparameter  { $$ = new ASTNode("formal parameter list", {$1}); }
                        | formalparameterlist COMMA formalparameter { $$->add($3); }
                        ;

formalparameter         : type identifier  { $$ = new ASTNode("formal parameter", {$1, $2}); }
                        ;

mainfunctiondeclaration : mainfunctiondeclarator block { $$ = new ASTNode("main function declaration", {$1, $2}); }
                        ;

mainfunctiondeclarator  : identifier PARENTHESIS_OPEN PARENTHESIS_CLOSE
                        ;

block                   : BRACE_OPEN blockstatements BRACE_CLOSE { $$ = new ASTNode("block", {$2}); }
                        | BRACE_OPEN BRACE_CLOSE { $$ = new ASTNode("block"); }
                        ;

blockstatements         : blockstatement { $$ = new ASTNode("block statements", {$1}); }
                        | blockstatements blockstatement { $$->add($2); }
                        ;

blockstatement          : variabledeclaration
                        | statement
                        ;

statement               : block
                        | SEMICOLON { $$ = new ASTNode("empty statement"); }
                        | statementexpression SEMICOLON { $$ = $1; }
                        | BREAK SEMICOLON
                        | RETURN expression SEMICOLON { $1->add($2); $$ = $1; /* forward the return node */ }
                        | RETURN SEMICOLON
                        | IF PARENTHESIS_OPEN expression PARENTHESIS_CLOSE statement { $$ = new ASTNode("if", {$3,$5}); }
                        | IF PARENTHESIS_OPEN expression PARENTHESIS_CLOSE statement ELSE statement { $$ = new ASTNode("if else", {$3,$5,$7}); }
                        | WHILE PARENTHESIS_OPEN expression PARENTHESIS_CLOSE statement { $$ = new ASTNode("while", {$3,$5}); }
                        ;

statementexpression     : assignment { $$ = new ASTNode("statement expression", {$1}); }
                        | functioninvocation { $$ = new ASTNode("statement expression", {$1}); }
                        ;

primary                 : literal
                        | PARENTHESIS_OPEN expression PARENTHESIS_CLOSE { $$ = $2; }
                        | functioninvocation
                        ;

argumentlist            : expression { $$ = new ASTNode("argument list", {$1}); }
                        | argumentlist COMMA expression { $$->add($3); }
                        ;

functioninvocation      : identifier PARENTHESIS_OPEN argumentlist PARENTHESIS_CLOSE { $$ = new ASTNode("function invocation", {$1,$3}); }
                        | identifier PARENTHESIS_OPEN PARENTHESIS_CLOSE { $$ = new ASTNode("function invocation", {$1}); }
                        ;

postfixexpression       : primary
                        | identifier
                        ;

unaryexpression         : MINUS unaryexpression { $$ = new ASTNode("-", {$2}); }
                        | NOT unaryexpression { $$ = new ASTNode("!", {$2}); }
                        | postfixexpression
                        ;

multiplicativeexpression: unaryexpression
                        | multiplicativeexpression MULTIPLY unaryexpression { $$ = new ASTNode("*", {$1,$3}); }
                        | multiplicativeexpression DIVIDE unaryexpression { $$ = new ASTNode("/", {$1,$3}); }
                        | multiplicativeexpression MODULO unaryexpression { $$ = new ASTNode("%", {$1,$3}); }
                        ;

additiveexpression      : multiplicativeexpression
                        | additiveexpression PLUS multiplicativeexpression { $$ = new ASTNode("+", {$1,$3}); }
                        | additiveexpression MINUS multiplicativeexpression { $$ = new ASTNode("-", {$1,$3}); }
                        ;

relationalexpression    : additiveexpression
                        | relationalexpression LT additiveexpression { $$ = new ASTNode("<", {$1,$3}); }
                        | relationalexpression GT additiveexpression { $$ = new ASTNode(">", {$1,$3}); }
                        | relationalexpression LE additiveexpression { $$ = new ASTNode("<=", {$1,$3}); }
                        | relationalexpression GE additiveexpression { $$ = new ASTNode(">=", {$1,$3}); }
                        ;

equalityexpression      : relationalexpression
                        | equalityexpression EQ relationalexpression { $$ = new ASTNode("==", {$1,$3}); }
                        | equalityexpression NE relationalexpression { $$ = new ASTNode("!=", {$1,$3}); }
                        ;

conditionalandexpression: equalityexpression
                        | conditionalandexpression AND equalityexpression { $$ = new ASTNode("&&", {$1,$3}); }
                        ;

conditionalorexpression : conditionalandexpression
                        | conditionalorexpression OR conditionalandexpression { $$ = new ASTNode("||", {$1,$3}); }
                        ;

assignmentexpression    : conditionalorexpression
                        | assignment
                        ;

assignment              : identifier ASSIGNMENT assignmentexpression { $$ = new ASTNode("=", {$1,$3}); }
                        ;

expression              : assignmentexpression
                        ;

%%

void yy::Parser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}